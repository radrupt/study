1. 基于数据库实现分布式锁
1.1 悲观锁  
利用select … where … for update 排他锁
1.2 乐观锁
select 的时候不加锁，但是有一个version的记录
等到update的时候，发现select的version和数据库oldversion不一致失败
优点：直接借助数据库，易于理解和使用
缺点：操作数据库有性能问题

2. 基于缓存（Redis等）实现分布式锁
2.1 获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个过期时间，超过改时间则自动释放锁
2.2 获取锁的时候再获取获取锁的超时时间，超过这个时间放弃获取锁
2.3 释放锁的时候通过uuid判断是不是该锁，若是，则只需delete操作释放锁
优点：性能好
缺点：通过超时来控制难以设定超时时间

3. 基于Zookeeper实现分布式锁
3.1 创建目录
3.2 线程A在目录下创建临时有序节点a，获取所有的节点，判断a是最小节点，获取锁
3.3 线程B在目录下创建临时有序节点b，获取所有的节点，判断b不是最小节点，监听最小节点
3.4 线程A完成任务，删除节点，触发线程B监听事件，线程B再次获取所有节点，发现自己是最小节点，获取锁
优点：有效解决单点问题（集群），不可重入问题，非阻塞问题（数据库的乐观锁，redis都是获取锁失败），实现比较简单
缺点：开销大，性能较redis低