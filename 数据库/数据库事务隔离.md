ACID中的isolation

1. Read uncommitted 读未提交
即事务A读到了事务B未提交事务的修改数据，脏读

2. Read committed 读已提交
事务A读存款余额100，事务B读存储余额100，事务B转移100到支付宝，事务A再转移失败，原因是两个事务重复读取了数据，重复读

3. Repeatable read 重复读
仅仅避免了两个事务不可重复读数据，但如果事务A读存款余额100，事务B增加了100，事务A消费100，结果事务A发现余额没变，以为出现了幻觉，幻象读

4. Serializable 序列化
保证所有事务顺序执行，但这样性能低

事务的隔离级别可以理解为：级别越大的隔离出现的问题越少，即事务之间的隔离性越好
如读未提交的问题是：a事务能读到b事务未提交的修改内容，出现脏读问题，隔离性不好，那么要做到隔离，只有在事务提交的时候才修改数据
如读已提交出现的问题是：a事务在过程中读了两次数据，由于中间数据被b事务修改并提交了，导致a事务两次读的结果不相同，出现了不可重复读问题，即b事务影响了a事务，隔离性有问题，那么要做到隔离，需要行级锁
如重复读的问题：a事务读了数据，b数据插入了新的数据，a事务再读发现条数增加，即b事务影响了a事务，隔离性有问题，那么要做到隔离需要表级锁