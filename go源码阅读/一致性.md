一致性

1. 什么是一致性？
一致性就是数据保持一致，在分布式系统中，可以理解为多个节点中数据的值是一致的。
在多核cpu中表示不同核心的缓存和主存数据的值是一致的。
在数据库的事务中，事务里的更新要么都成功，要么都失败。
数据库和redis中的数据一致性。
hash一致性，为了解决热点问题，保证平衡性（数据均匀分布所有节点），单调性（节点增加或减少后热点数据只会在两个节点上进行迁移）,分散性（如相同数据结合了客户端版本，那么生成的cache key其实是不一样的，意味着分布式中相同数据会存到不同的节点，且导致了时间不一致问题）。
2. golang中的一致性如何保证的？
golang中的一致性无非就是原子操作原子性，这里不聊通过锁实现的原子操作，只聊atomic包中的原子操作。  
比如atomic.Value.Store, 通过几件事情保证原子性，  
1. 更改数据的时候保证当前goroutine不被抢占  
2. 修改前通过CompareAndSwapPointer设置一个修改标志，表示当前数据正在被修改，其他修改只能自旋等待修改结束
3. CompareAndSwapPointer是如何保证原子性的呢？这个时候会有多个goroutine在读个核心上并行执行，在主存，总线，每个核心有各寄存器各自缓存这样的结构下，如何做到原子性。不同架构不同的实现，比如再inter的cpu架构中，一个cpu再修改内存块，那么就会通过总线锁来避免其他cpu修改相同数据。在amd的cpu架构中是通过mesi的一致协议保证原子操作，即首先对缓存行分4中状态  
第一种：M(Modified)，这行数据有效，但数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。  
第二种：E(Exclusive)，这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中，不存在于其他cache中，或其它cache中数据无效。  
第三种：S(Shared)，这行数据有效，数据和内存中的数据一致，数据存在于很多cpu的Cache中。  
第四中：I(Invalid)，这行数据无效。  
基于以上四种类型，当cpu1使用主存数据c到cache，cache中c状态为独享，当cpu2使用主存数据c到cache，cache中c状态为独占，并发消息到总线告知其他cpu读取了变量，这个时候各cpu都知道其他cpu读取了变量，各cache中的c都变为共享状态，当cpu1修改数据c，c的状态变为修改，同时通过总线告知cpu2c被修改，cpu2的cache中c变为无效，cpu1修改cache c的数据后，会立刻写回至主存，此时cpu1 cache c状态变为独享。

如果多个CPU同时都将变量置为M修改状态，那怎么办？
首先多个CPU都想将变量置为M修改状态，那么系统会有裁决机制，保证只有一个CPU能够操作成功，因此不会存在多个M状态的数据

参考：https://www.cnblogs.com/jackeason/p/11336317.html